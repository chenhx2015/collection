// 冒泡排序 🌿🌿🌿
// 原理：从把一个数组中的每一个数从前往后依次进行比较，然后根据大小交换位置，每一轮的比较都确定出一个当轮比较的最大值，最终实现数组的大小排序
// 交换的次数最多，所以它的性能是最差的
// 思路：1.创建待排序的数组 2.确定轮数：假设数组中有n个数，则需要n轮，而每一轮中比较的次数都要减去已经确定的数值，即第i轮需要比较的次数为：n-i

// 时间复杂度： 平均时间复杂度O(n*n) 、最好情况O(n)、最差情况O(n*n)
// 空间复杂度： O(1)
// 稳定性：稳定

function bubbleSort(arr) {
  var max = arr.length - 1;
  // 外层循环 控制趟数（比如是5个数的数组，那就要比4趟） 每一次找到一个最大值
  for (var j = 0; j < max; j++) {
    // 如果某次循环完后，没有任何两数进行交换，就将标志位 done 设置为 true，表示排序完成
    // 这样我们就可以减少不必要的排序，提高性能
    var done = true;
    for (var i = 0; i < max - j; i++) {
      // 内层循环控制比较的次数 并判断大小
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        done = false;
      }
    }
    if (done) {
      break;
    }
  }
  console.log(arr);
}

// bubbleSort([12, 15, 1, 4, 6]);

// 总结
// 1、外层 for 循环控制循环趟数
// 2、内层 for 循环控制每趟多少次 且进行两数交换，找每次的最大数，排到最后
// 3、设置一个标志位，减少不必要的循环

// 面试时其他情况的考虑（细节优化）：
// 1.是否是数组 & 长度大于1 ？，是数组才排序
// 2.如上标记位优化
